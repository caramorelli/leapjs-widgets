<html>
<head>
  <meta charset="utf-8">
  <!--<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>-->
  <script src="js/three.js"></script>
  <script type="text/javascript" src="js/leap-0.6.5pre.js"></script>
  <script src="js/leap-plugins-0.1.11pre.js"></script>

  <script type="text/javascript" src="js/coffee-script.js"></script>


  <style>
    body {
      margin: 0;
    }
    canvas.leap-boneHand{
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #view-source {
      position: absolute;
      top: 0;
      right: 0;
      margin: 10px;
      z-index: 10;
    }
  </style>

</head>
<body>
</body>

<script type="application/javascript">
  'use strict';

  // Set up plugins

  Leap.loop()
    .use('transform', {
      vr: 'desktop' // Switch to meters.
    })
    .use('boneHand', {
      targetEl: document.body,
      jointColor: new THREE.Color(0xffffff),
      rendererOps: {antialias: true}
    });


  var scene = Leap.loopController.plugins.boneHand.scene;
  var camera = Leap.loopController.plugins.boneHand.camera;
  var renderer = Leap.loopController.plugins.boneHand.renderer;
  camera.position.set( 0, 0.3, 0.6 );

  var axisHelper = new THREE.AxisHelper( 0.1 );
  scene.add( axisHelper );


  var geo = new THREE.CylinderGeometry(0.04, 0.08, 0.16, 5);
  var material = new THREE.MeshPhongMaterial();
  var mesh = new THREE.Mesh(geo, material);
  mesh.matrixAutoUpdate = false; // !

  scene.add(mesh);

  // Sets this quaternion to be the component of the rotation which took place around a given axis
  // Takes a normalized Vector3 axis
  THREE.Quaternion.prototype.rotationAroundAxis = function(axis){
    // http://stackoverflow.com/questions/3684269/component-of-a-quaternion-rotation-around-an-axis
    axis.normalize(); // (!)

    // => z2 = (-x1 * x2 - y1 * y2) / z1
    var orthoVec = new THREE.Vector3(1,1,1);
    orthoVec.z = (-axis.x * orthoVec.z - axis.y * orthoVec.y) / axis.z;
    orthoVec.normalize();

    var targetVec = orthoVec.clone();

    targetVec.applyQuaternion(this);

    targetVec.projectOnPlane(axis);

    this.setFromUnitVectors(orthoVec, targetVec);
  }

</script>

<script type="text/coffeescript">


# add small rotation on random positive normalized axis
q = (new THREE.Quaternion).setFromAxisAngle(
  new THREE.Vector3( (Math.random() * 10 ), Math.random(), 0 ).normalize(),
  Math.PI / (Math.random() * 1)
)
#mesh.quaternion.multiply(q)
mesh.updateMatrix()


up = new THREE.Vector3(0,Math.sqrt(2),Math.sqrt(2))

# for each hand, hold present and past rotation state
q1h1 = new THREE.Quaternion # 1 most recent
q2h1 = new THREE.Quaternion # further back in time
q3h1 = new THREE.Quaternion # delta

q1h2 = new THREE.Quaternion
q2h2 = new THREE.Quaternion
q3h2 = new THREE.Quaternion

m1o = null # matrix for object
m2o = new THREE.Matrix4
mesh.matrixWorldInverse = new THREE.Matrix4

q1o = null
q2o = new THREE.Quaternion

qTemp = new THREE.Quaternion
mTemp = new THREE.Matrix4
vTemp = new THREE.Vector3

Leap.loopController.on 'frame', (frame)->

  return unless frame.hands.length == 2

  # centerpoint between the hands
  center = new THREE.Vector3
  temp = new THREE.Vector3
  for hand in frame.hands
    temp.fromArray(hand.palmPosition)
    center.add(temp)

  center.divideScalar(frame.hands.length)
  mesh.position.copy(center)


  axis = (new THREE.Vector3).fromArray(frame.hands[0].palmPosition)
  vTemp.fromArray(frame.hands[1].palmPosition)
  axis.sub(vTemp)

  # 2: use deltas

  # we can use any arbitrary up-vector, as we're only looking for differences (ultimately)
  if m1o
    m2o.copy(m1o)
    m1o.lookAt(mesh.position, temp, up)
    q2o.copy(q1o)
    q1o.setFromRotationMatrix(m1o)
  else
    m1o = new THREE.Matrix4
    m1o.lookAt(mesh.position, temp, up)
    q1o = new THREE.Quaternion
    q1o.setFromRotationMatrix(m1o)
    return

  # rotation since Last Frame
  # (note, this could alternatively be done with hand.sinceFrame, but that returns a mat3 (and may work on deviceFrames instead?)
  mTemp.copy(m1o).multiply(m2o.getInverse(m2o.clone()))

  # multiply our offset first (todo: check against matrixWorld)
  mesh.matrix.multiplyMatrices(mTemp, mesh.matrix.clone())

  mesh.matrixWorldNeedsUpdate = true


  # Use pitch of hands (actually, rotation on axis of plane normal to between hands) to alter on between-hands axis.

  q2h1.copy(q1h1);
  q1h1.setFromRotationMatrix { elements: frame.hands[0].matrix() }
  q3h1.copy(q1h1).multiply( qTemp.copy(q2h1).inverse() )

  q2h2.copy(q1h2);
  q1h2.setFromRotationMatrix { elements: frame.hands[1].matrix() }

  # extract existing quaternion, multiply by delta quaternion, put back in to the matrix
  # for now, we don't restrict to axis, just for fun. (simplifying, and it could actually be nice? probably not nice.)
  qTemp.setFromRotationMatrix(mesh.matrix);

  q3h1.rotationAroundAxis(axis)

  q3h1.multiply(qTemp);
  mesh.matrix.makeRotationFromQuaternion(q3h1);

  mesh.matrix.setPosition(mesh.position)


  # 3: average rotation of hands around axis between hands to alter the up-vector



  # 4: create object field

  # 5: apply to camera, instead of object (make this toggleable)

  # 6: add intertial effects




</script>

</html>